package norswap.autumn;

import norswap.autumn.parsers.Not;
import norswap.autumn.util.ArrayStack;
import norswap.utils.Slot;
import norswap.utils.ArrayListLong;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.IntFunction;

import static norswap.autumn.ParseOptions.*;

/**
 * The context associated with <i>a parse</i>, which is the the invocation of a (root) parser on
 * some input â€” either a String ({@link #string}) or a list ({@link #list}).
 *
 * <p>Instances of this class cannot be created by the user, instead they are generated by one of
 * the {@link Autumn} {@code .run} methods. However, custom {@link Parser} implementations
 * can (and should) access this class.
 *
 * <p>Most fields of this class are public in order to enable advanced parser implementations, but
 * it is often not necessary to touch them at all. See the relevant part of the Autumn manual for
 * more information.
 */
public final class Parse
{
    // ---------------------------------------------------------------------------------------------

    /**
     * Position within the input.
     */
    public int pos = 0;

    // ---------------------------------------------------------------------------------------------

    /**
     * Position of the furthest encountered error, or -1 if no error have been encountered.
     */
    public int error = -1;

    // ---------------------------------------------------------------------------------------------

    /**
     * One of the two forms of input the parse may have.
     */
    public final String string;

    // ---------------------------------------------------------------------------------------------

    /**
     * One of the two forms of input the parse may have.
     */
    public final List<?> list;

    // ---------------------------------------------------------------------------------------------

    /**
     * The parse options used to construct this parse object.
     */
    public final ParseOptions options;

    // ---------------------------------------------------------------------------------------------

    /**
     * The list of side-effects that have been applied during this parse.
     */
    public final Log log = new Log();

    // ---------------------------------------------------------------------------------------------

    /**
     * A stack that can be used to build ASTs.
     *
     * <p>This stack should only be mutated through a {@link SideEffect}. The helper methods {@link
     * #push} , {@link #pop()}, etc... do this for you automatically.
     */
    public final ArrayStack<Object> stack = new ArrayStack<>();

    // ---------------------------------------------------------------------------------------------

    /**
     * Use this map to store custom parsing state. If state changes must be undone when
     * backtracking (as is usual), these states should usually be modified exclusively through a
     * {@link SideEffect}.
     *
     * <p>Use {@link ParseState} to transparently access this map and cache its values for
     * increase performance.
     */
    public final Map<Object, Object> states = new HashMap<>();

    // ---------------------------------------------------------------------------------------------

    /** @see ParseOptions#RECORD_CALL_STACK */
    final boolean record_call_stack;

    // ---------------------------------------------------------------------------------------------

    /** @see ParseOption#TRACE */
    final boolean trace;

    // ---------------------------------------------------------------------------------------------

    /**
     * List of {@link ParseState} used during this parse, i.e. parse states whose keys
     * are registered in {@link #states}.
     */
    ArrayList<ParseState<?>> parse_state_kinds = new ArrayList<>();

    // ---------------------------------------------------------------------------------------------

    /**
     * The current parser invocation stack if {@link ParseOptions#RECORD_CALL_STACK} is set,
     * null otherwise.
     *
     * <p>Only access if required (and check if the option is set!). No base parsers use this.
     */
    public ParserCallStack call_stack;

    // ---------------------------------------------------------------------------------------------

    /**
     * If {@link ParseOptions#RECORD_CALL_STACK} is set, the stack of parser invocations that lead
     * to the furthest error (at position {@link #error}), or null if there were no parse errors.
     * Otherwise, always null.
     *
     * <p>Only access if required (and check if the option is set!). Only the {@link Not} base
     * parser uses this.
     */
    public ParserCallStack error_call_stack;

    // ---------------------------------------------------------------------------------------------

    /**
     * A stack used to record the execution time of completed parser invocations in tracing mode
     * ({@link ParseOptions#TRACE}). See {@link Parser#tracing_parse(Parse)}.
     */
    final ArrayListLong trace_timings;

    // ---------------------------------------------------------------------------------------------

    /**
     * Maps parser names to a set of parser metrics.
     *
     * <p>Can be reused accross parses using {@link ParseOptions#METRICS(ParseMetrics)}.
     */
    final ParseMetrics parse_metrics;

    // ---------------------------------------------------------------------------------------------

    private Parse (String string, List<?> list, ParseOptions options)
    {
        options = options != null ? options : DEFAULT_PARSE_OPTIONS;
        this.string = string;
        this.list = list;
        this.options = options;
        this.record_call_stack = options.has(RECORD_CALL_STACK);
        this.trace = options.has(TRACE);
        call_stack = record_call_stack ? new ParserCallStack() : null;
        trace_timings = trace ? new ArrayListLong(256) : null;
        ParseMetrics metrics = options.value(METRICS);
        parse_metrics = metrics == null && trace
            ? new ParseMetrics()
            : metrics;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * @see Autumn#run
     */
    static ParseResult run (Parser parser, String string, List<?> list, ParseOptions options)
    {
        Parse parse = new Parse(string, list, options);
        Throwable thrown = null;
        boolean success = false;
        try { success = parser.parse(parse); }
        catch (Throwable t) { thrown = t; }
        finally {
            for (ParseState<?> state: parse.parse_state_kinds)
                state.discard_cache(parse);
        }

        boolean full_match
            = success && parse.pos == parse.input_length();

        int match_size
            = success ? parse.pos : -1;

        int error_position
            = full_match
                ? -1
                : thrown != null
                    ? parse.pos
                    : parse.error;

        ParserCallStack error_call_stack
            = thrown != null
                ? parse.error_call_stack
                : full_match
                    ? parse.call_stack
                    : null;

        return new ParseResult(
            success,
            full_match,
            match_size,
            thrown,
            parser,
            options,
            error_position,
            parse.stack,
            parse.states,
            error_call_stack,
            parse.parse_metrics);
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * A generic method returning the size of the input that abstracts over whether this parse
     * is over a string or a list.
     */
    public int input_length()
    {
        return string != null
            ? string.length()
            : list.size();
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns the character from {@link #string} at the given index,
     * or 0 if {@code index == string.length}.
     */
    public char char_at (int index)
    {
        assert string != null;
        return index != string.length()
            ? string.charAt(index)
            : 0;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Returns the object from {@link #list} at the given index,
     * or null if {@code index == list.size()}.
     */
    public Object object_at (int index)
    {
        assert list != null;
        return index != list.size()
            ? list.get(index)
            : null;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Push an item onto the AST {@link #stack} through a {@link SideEffect}.
     */
    @SuppressWarnings("unchecked")
    public void push (Object item)
    {
        log.apply(() -> stack.push(item), stack::pop);
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Side-effecting ({@link SideEffect}) version of {@link ArrayStack#pop()}, for use with {@link
     * #stack}.
     */
    public Object pop()
    {
        Slot<Object> slot = new Slot<>();
        log.apply(  () -> slot.x = stack.pop(),
                    () -> stack.push(slot.x));
        return slot.x;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Side-effecting ({@link SideEffect}) version of {@link ArrayStack#pop(int, IntFunction)}, for
     * use with {@link #stack}.
     */
    public Object[] pop (int amount)
    {
        Slot<Object[]> slot = new Slot<>();
        log.apply(
            () -> slot.x = stack.pop(amount, Object[]::new),
            () -> stack.push(slot.x));
        return slot.x;
    }

    // ---------------------------------------------------------------------------------------------

    /**
     * Side-effecting ({@link SideEffect}) version of {@link ArrayStack#pop_from(int, IntFunction)}, for
     * use with {@link #stack}.
     *
     * <p>The registered side-effect will remember the amount to pop, not the specific index
     * passed to the function, which is generally the desired semantics.
     */
    public Object[] pop_from (int index)
    {
        return pop(stack.size() - index);
    }

    // ---------------------------------------------------------------------------------------------

}
